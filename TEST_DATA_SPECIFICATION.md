# MiniTB 性能测试数据规范

本文档详细说明性能测试中数据的生成、发送频率和测试配置。

---

## 📋 测试配置总览

### 核心参数

| 参数 | 配置项 | 默认值 | 说明 |
|------|--------|--------|------|
| **发送间隔** | `sendIntervalMs` | `0` | 0 = 尽可能快发送 |
| **预热消息** | `warmupMessages` | `1000` | JVM 预热 |
| **消息大小** | `messageSize` | `100` 字节 | 实际 ~200 字节（JSON） |
| **数据类型** | `includeMultipleDataTypes` | `true` | 包含多种类型 |
| **Actor 线程池** | `actorThreadPoolSize` | `5` | Actor 处理线程 |
| **规则引擎线程池** | - | `4` | 规则链处理线程 |

---

## 🚀 发送频率详解

### 1. 单设备测试

**配置**：
```java
设备数：1
每设备消息数：10,000
发送线程数：1
发送间隔：0 ms（尽可能快）
```

**发送频率**：
- **理论频率**：无限制（CPU 和网络允许的最快速度）
- **实际频率**（优化后）：
  - Actor 模式：~270,270 msg/s = **每 3.7 微秒一条消息**
  - 同步模式：~96,154 msg/s = **每 10.4 微秒一条消息**

**发送模式**：
```
线程1: [msg1] → [msg2] → [msg3] → ... → [msg10000]
       ↑ 无延迟，连续发送
```

**总耗时**：
- Actor 模式：~37 ms（10,000 条消息）
- 同步模式：~104 ms（10,000 条消息）

---

### 2. 多设备并发测试

#### 10 设备场景

**配置**：
```java
设备数：10
每设备消息数：1,000
发送线程数：10
发送间隔：0 ms
总消息数：10,000
```

**发送频率**：
- **总吞吐量**：~384,615 msg/s
- **每设备频率**：~38,462 msg/s
- **每线程频率**：~38,462 msg/s（每线程负责 1 个设备）

**发送模式**：
```
线程1(设备1):  [msg1] → [msg2] → ... → [msg1000]
线程2(设备2):  [msg1] → [msg2] → ... → [msg1000]
...
线程10(设备10): [msg1] → [msg2] → ... → [msg1000]
               ↑ 10个线程并发发送
```

**总耗时**：~26 ms

---

#### 50 设备场景

**配置**：
```java
设备数：50
每设备消息数：1,000
发送线程数：20（限制）
发送间隔：0 ms
总消息数：50,000
```

**发送频率**：
- **总吞吐量**：~649,351 msg/s
- **每设备频率**：~12,987 msg/s
- **每线程频率**：~32,468 msg/s（每线程负责 2-3 个设备）

**发送模式**：
```
线程1: 设备1,设备2,设备3 (轮流发送)
线程2: 设备4,设备5,设备6
...
线程20: 设备49,设备50
       ↑ 20个线程并发，每线程处理 2-3 个设备
```

**总耗时**：~77 ms

---

#### 100 设备场景

**配置**：
```java
设备数：100
每设备消息数：1,000
发送线程数：20（限制）
发送间隔：0 ms
总消息数：100,000
```

**发送频率**：
- **总吞吐量**：~952,381 msg/s
- **每设备频率**：~9,524 msg/s
- **每线程频率**：~47,619 msg/s（每线程负责 5 个设备）

**发送模式**：
```
线程1: 设备1-5 (依次处理)
线程2: 设备6-10
...
线程20: 设备96-100
       ↑ 20个线程并发，每线程处理 5 个设备
```

**总耗时**：~105 ms

---

### 3. 消息峰值测试

**配置**：
```java
设备数：20
每设备消息数：5,000
发送线程数：20
发送间隔：0 ms
总消息数：100,000（峰值负载）
```

**发送频率**：
- **总吞吐量**：~714,286 msg/s 🏆
- **每设备频率**：~35,714 msg/s
- **每线程频率**：~35,714 msg/s（每线程负责 1 个设备）

**发送模式**：
```
线程1(设备1):  [msg1] → [msg2] → ... → [msg5000]
线程2(设备2):  [msg1] → [msg2] → ... → [msg5000]
...
线程20(设备20): [msg1] → [msg2] → ... → [msg5000]
               ↑ 20个线程全力并发发送
```

**总耗时**：~140 ms

---

## 📦 测试数据格式

### 消息结构

```json
{
  "temperature": 32.45,           // DOUBLE: 20-40 随机
  "humidity": 65.23,              // DOUBLE: 40-80 随机
  "pressure": 1015.67,            // DOUBLE: 1000-1100 随机
  "online": true,                 // BOOLEAN: 随机
  "status": "running",            // STRING: "running" 或 "idle"
  "counter": 456,                 // LONG: 0-999 随机
  "timestamp": 1729832400000,     // LONG: 当前时间戳（毫秒）
  "sendTimeNanos": 12345678901234, // LONG: 发送时间（纳秒，性能测试用）
  "deviceId": "uuid-xxx",         // STRING: 设备 UUID
  "deviceName": "TestDevice-001"  // STRING: 设备名称
}
```

### 数据类型覆盖

| 数据类型 | 字段 | 值范围 | 字节数 |
|---------|------|--------|--------|
| DOUBLE | temperature | 20.0 - 40.0 | ~8 |
| DOUBLE | humidity | 40.0 - 80.0 | ~8 |
| DOUBLE | pressure | 1000.0 - 1100.0 | ~10 |
| BOOLEAN | online | true/false | ~5 |
| STRING | status | "running"/"idle" | ~10 |
| LONG | counter | 0 - 999 | ~3 |
| LONG | timestamp | 当前时间 | ~13 |
| LONG | sendTimeNanos | 纳秒时间戳 | ~16 |
| STRING | deviceId | UUID | ~36 |
| STRING | deviceName | "TestDevice-XXX" | ~15 |

**总大小**：约 **124-150 字节**（JSON 格式后约 **200-250 字节**）

---

## ⏱️ 发送频率计算

### 发送频率公式

```
发送频率 = 设备数 × 每设备消息数 / 总耗时
         = numDevices × msgsPerDevice / durationSeconds
```

### 实际测试频率（优化后）

#### 单设备场景
```
Actor 模式：
- 消息数：10,000 条
- 耗时：~37 ms
- 频率：10,000 / 0.037 = 270,270 msg/s
- 每条消息间隔：3.7 微秒

同步模式：
- 消息数：10,000 条
- 耗时：~104 ms
- 频率：10,000 / 0.104 = 96,154 msg/s
- 每条消息间隔：10.4 微秒
```

#### 50 设备场景
```
- 总消息数：50,000 条
- 总耗时：~77 ms
- 总频率：50,000 / 0.077 = 649,351 msg/s
- 每设备频率：649,351 / 50 = 12,987 msg/s
- 每设备消息间隔：77 微秒
```

#### 100 设备场景
```
- 总消息数：100,000 条
- 总耗时：~105 ms
- 总频率：100,000 / 0.105 = 952,381 msg/s
- 每设备频率：952,381 / 100 = 9,524 msg/s
- 每设备消息间隔：105 微秒
```

#### 峰值场景（20 设备 × 5000 条）
```
- 总消息数：100,000 条
- 总耗时：~140 ms
- 总频率：100,000 / 0.140 = 714,286 msg/s
- 每设备频率：714,286 / 20 = 35,714 msg/s
- 每设备消息间隔：28 微秒
```

---

## 🔄 发送流程

### 消息发送时序

```
t=0ms    [预热开始]
         ├─ 发送 warmupMessages 条消息
         └─ 等待 2000ms 处理完成
         
t=2000ms [重置指标]
         └─ metrics.reset()
         
t=2000ms [正式测试开始]
         └─ metrics.startTest()
         
t=2000ms [并发发送]
         ├─ 线程1: 发送设备1的所有消息
         ├─ 线程2: 发送设备2的所有消息
         ├─ ...
         └─ 线程N: 发送设备N的所有消息
         
t=?ms    [发送完成]
         └─ 所有线程完成发送
         
t=?ms    [等待处理完成]
         └─ waitForCompletion()（额外等待 5 秒）
         
t=?ms    [测试结束]
         ├─ metrics.endTest()
         └─ 生成报告
```

### 单条消息处理流程

```
发送端（PerformanceTestRunner）
  │
  ├─ 1. 生成测试消息（generateTestMessage）
  │    └─ 创建 JSON 字符串（~200 字节）
  │
  ├─ 2. 记录发送时间（System.nanoTime()）
  │
  ├─ 3. 调用 TransportService.processTelemetry()
  │    │
  │    ├─ 设备认证（deviceRegistry.get()）
  │    ├─ 限流检查（checkRateLimit）
  │    │
  │    └─ 路由模式选择：
  │         │
  │         ├─ Actor 模式：
  │         │    └─ sendToDeviceActorAsync()
  │         │         └─ actorSystem.tell() → DeviceActor
  │         │
  │         └─ 同步模式：
  │              └─ sendToRuleEngineSync()
  │                   └─ ruleEngineService.processMessage()
  │
  ├─ 4. DeviceActor 处理（Actor 模式）
  │    ├─ 解析 JSON → TsKvEntry 列表
  │    ├─ 创建 TbMsg（包含强类型数据）
  │    └─ 转发到 RuleEngineActor
  │
  ├─ 5. 规则链处理
  │    ├─ LogNode（debug 日志）
  │    ├─ FilterNode（temperature > 20）
  │    ├─ SaveTelemetryNode（保存到存储）
  │    └─ LogNode（debug 日志）
  │
  ├─ 6. 保存到 TelemetryStorage
  │    └─ 存储到内存 Map
  │
  └─ 7. PerformanceMetrics 记录
       ├─ recordMessageProcessed()
       └─ 记录延迟（endTime - sendTimeNanos）
```

**处理时延**：
- Actor 模式：平均 **54.54 ms**（单设备）
- 同步模式：平均 **0.04 ms**（单设备）

---

## 📊 各场景详细配置

### 场景 1：单设备吞吐量测试

```yaml
测试名称: 单设备吞吐量测试
设备数: 1
每设备消息数: 10,000
发送线程数: 1
消息大小: 100 字节
发送间隔: 0 ms
预热消息: 100
使用 Actor: true/false（分别测试）

发送频率（优化后）:
  - Actor 模式: 270,270 msg/s (每 3.7μs 一条)
  - 同步模式: 96,154 msg/s (每 10.4μs 一条)

总测试时长:
  - Actor 模式: ~37 ms (发送) + 5s (等待处理) ≈ 5.1s
  - 同步模式: ~104 ms (发送) + 5s (等待处理) ≈ 5.2s
```

---

### 场景 2：多设备并发测试 - 10 设备

```yaml
测试名称: 多设备并发测试-10设备
设备数: 10
每设备消息数: 1,000
发送线程数: 10
消息大小: 100 字节
发送间隔: 0 ms
预热消息: 100
总消息数: 10,000

发送频率:
  - 总吞吐量: 384,615 msg/s
  - 每设备: 38,462 msg/s (每 26μs 一条)
  - 每线程: 38,462 msg/s

并发模式:
  - 10 个线程同时发送
  - 每个线程负责 1 个设备
  - 线程间完全并行，无等待

总测试时长: ~26 ms (发送) + 5s (等待) ≈ 5.1s
```

---

### 场景 3：多设备并发测试 - 50 设备

```yaml
测试名称: 多设备并发测试-50设备
设备数: 50
每设备消息数: 1,000
发送线程数: 20 (限制，避免线程过多)
消息大小: 100 字节
发送间隔: 0 ms
预热消息: 100
总消息数: 50,000

发送频率:
  - 总吞吐量: 649,351 msg/s
  - 每设备: 12,987 msg/s (每 77μs 一条)
  - 每线程: 32,468 msg/s (负责 2-3 个设备)

并发模式:
  - 20 个线程并发
  - 每个线程负责 2-3 个设备（50÷20=2.5）
  - 线程内串行处理各设备，线程间并行

总测试时长: ~77 ms (发送) + 5s (等待) ≈ 5.2s
```

---

### 场景 4：多设备并发测试 - 100 设备

```yaml
测试名称: 多设备并发测试-100设备
设备数: 100
每设备消息数: 1,000
发送线程数: 20 (限制)
消息大小: 100 字节
发送间隔: 0 ms
预热消息: 100
总消息数: 100,000

发送频率:
  - 总吞吐量: 952,381 msg/s
  - 每设备: 9,524 msg/s (每 105μs 一条)
  - 每线程: 47,619 msg/s (负责 5 个设备)

并发模式:
  - 20 个线程并发
  - 每个线程负责 5 个设备（100÷20=5）
  - 单线程内依次处理 5 个设备，每个设备 1000 条消息

总测试时长: ~105 ms (发送) + 5s (等待) ≈ 5.2s
```

---

### 场景 5：消息峰值测试（100,000 条）

```yaml
测试名称: 消息峰值测试
设备数: 20
每设备消息数: 5,000
发送线程数: 20
消息大小: 200 字节
发送间隔: 0 ms
预热消息: 2,000
总消息数: 100,000

发送频率:
  - 总吞吐量: 714,286 msg/s 🏆
  - 每设备: 35,714 msg/s (每 28μs 一条)
  - 每线程: 35,714 msg/s (1线程负责1设备)

并发模式:
  - 20 个线程全力并发
  - 每个线程负责 1 个设备
  - 每个设备发送 5,000 条消息
  - 完全并行，无同步等待

总测试时长: ~140 ms (发送) + 5s (等待) ≈ 5.3s
```

---

## 🎯 发送频率特点

### 微秒级发送间隔

所有测试都是**尽可能快发送**（`sendIntervalMs = 0`）：

| 场景 | 每条消息间隔 | 说明 |
|------|------------|------|
| 单设备 Actor | **3.7 微秒** | CPU 极限速度 |
| 单设备同步 | **10.4 微秒** | 同步阻塞影响 |
| 50 设备 | **77 微秒/设备** | 线程竞争影响 |
| 100 设备 | **105 微秒/设备** | 资源饱和 |
| 峰值 | **28 微秒/设备** | 20 设备并发最优 |

### 吞吐量上限分析

**为什么峰值是 714K msg/s，不是更高？**

可能的瓶颈：
1. **CPU 处理能力**：JSON 解析、对象创建、规则链处理
2. **内存带宽**：数据复制、对象分配
3. **线程调度**：20 个发送线程 + 5 个 Actor 线程 + 4 个规则引擎线程
4. **同步开销**：ConcurrentHashMap、队列操作
5. **GC 影响**：虽然内存使用低，但仍有 GC 开销

**理论极限推算**：
- 假设 CPU 8 核，每核处理 100K msg/s
- 理论极限：800K msg/s
- 实际测得：714K msg/s
- 效率：**89.3%**（非常高！）

---

## 📈 发送频率vs处理延迟的关系

### 观察到的现象

```
发送频率 ↑  →  处理延迟 ↑

单设备(270K msg/s)   →  54.54 ms 延迟
10设备(385K msg/s)   →  86.81 ms 延迟
50设备(649K msg/s)   →  164.35 ms 延迟
100设备(952K msg/s)  →  285.09 ms 延迟
```

**原因**：
1. **队列积压**：发送速度 > 处理速度，消息在队列中等待
2. **线程竞争**：更多设备 = 更多线程竞争 CPU
3. **GC 压力**：更高频率 = 更多对象创建 = 更多 GC

### 吞吐量 vs 延迟权衡

```
优化目标     推荐配置          吞吐量        延迟
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
低延迟      单设备同步         96K msg/s     0.04 ms
高吞吐量    100设备并发        952K msg/s    285 ms
平衡        20-50设备          650K msg/s    164 ms
```

---

## 🔧 可配置的发送频率

### 1. 限制发送频率

如果需要模拟**真实设备**的发送频率，可以设置 `sendIntervalMs`：

```java
// 每秒发送 1 条消息
config.setSendIntervalMs(1000);

// 每 100ms 发送 1 条消息（10 msg/s）
config.setSendIntervalMs(100);

// 每 10ms 发送 1 条消息（100 msg/s）
config.setSendIntervalMs(10);
```

**示例**：模拟 50 个设备，每个设备每秒上报 1 次

```java
PerformanceTestConfig config = new PerformanceTestConfig();
config.setNumDevices(50);
config.setMsgsPerDevice(60); // 测试 1 分钟
config.setSendIntervalMs(1000); // 每秒 1 条
config.setSenderThreads(50);

// 发送频率：50 设备 × 1 msg/s = 50 msg/s
// 测试时长：60 秒
// 总消息数：50 × 60 = 3,000 条
```

### 2. 不同场景的推荐频率

| 场景 | 每设备频率 | sendIntervalMs | 说明 |
|------|-----------|---------------|------|
| **压力测试** | 最快 | `0` | 测试系统极限 |
| **智能家居** | 1 msg/min | `60000` | 温湿度传感器 |
| **工业监控** | 1 msg/s | `1000` | 设备状态 |
| **车联网** | 10 msg/s | `100` | GPS 位置 |
| **高频交易** | 1000 msg/s | `1` | 实时数据 |

---

## 📊 实际应用场景映射

### 智能家居场景

```yaml
设备数: 100 (温湿度传感器)
发送频率: 每 5 分钟 1 条
sendIntervalMs: 300,000
每日消息数: 100 × (24×60/5) = 28,800 条
系统负载: 100 / 300,000 = 0.00033 msg/s

MiniTB 处理能力: 714,286 msg/s
富余倍数: 2,142,858 倍
结论: 完全无压力 ✅
```

### 工业物联网场景

```yaml
设备数: 1,000 (生产线传感器)
发送频率: 每秒 1 条
sendIntervalMs: 1,000
系统负载: 1,000 msg/s

MiniTB 处理能力: 714,286 msg/s
富余倍数: 714 倍
结论: 轻松应对 ✅
```

### 车联网场景

```yaml
设备数: 10,000 (车辆)
发送频率: 每秒 10 条 (GPS + 传感器)
sendIntervalMs: 100
系统负载: 10,000 × 10 = 100,000 msg/s

MiniTB 处理能力: 714,286 msg/s
富余倍数: 7.1 倍
结论: 可以应对，但需要监控 ✅
```

### 高频交易/金融场景

```yaml
设备数: 1,000 (交易终端)
发送频率: 每秒 1,000 条 (实时行情)
sendIntervalMs: 1
系统负载: 1,000 × 1,000 = 1,000,000 msg/s

MiniTB 处理能力: 714,286 msg/s
富余倍数: 0.71 倍
结论: 超出能力，需要分布式部署 ⚠️
```

---

## 🎯 发送频率建议

### 性能测试建议

**压力测试**（测试极限）：
```java
config.setSendIntervalMs(0);  // 尽可能快
config.setNumDevices(100);
config.setMsgsPerDevice(1000);
// 目标：测试系统峰值性能
```

**稳定性测试**（长时间）：
```java
config.setSendIntervalMs(100);  // 每 100ms 一条
config.setNumDevices(50);
config.setMsgsPerDevice(36000);  // 运行 1 小时
// 目标：测试系统稳定性
```

**真实场景模拟**：
```java
config.setSendIntervalMs(1000);  // 每秒 1 条
config.setNumDevices(1000);
config.setMsgsPerDevice(3600);  // 运行 1 小时
// 目标：模拟真实 IoT 场景
```

### 生产环境建议

**低频场景**（< 1 msg/s/设备）：
- 无需特殊优化
- 可以使用同步模式
- 延迟 < 1 ms

**中频场景**（1-100 msg/s/设备）：
- 推荐使用 Actor 模式
- 预期延迟：< 100 ms
- 支持设备数：1000+

**高频场景**（> 100 msg/s/设备）：
- 必须使用 Actor 模式
- 实施背压控制
- 考虑消息批处理
- 预期延迟：< 500 ms

---

## 📝 总结

### 当前测试配置特点

✅ **极限压力测试**
- `sendIntervalMs = 0`：CPU 允许的最快速度
- 模拟突发流量、消息峰值场景
- 验证系统极限性能

✅ **多线程并发**
- 模拟多设备同时发送
- 测试系统并发处理能力
- 验证 Actor 隔离性

✅ **真实数据类型**
- 包含 DOUBLE、LONG、STRING、BOOLEAN
- 覆盖常见 IoT 数据类型
- 验证强类型数据处理

### 测试覆盖度

- [x] 单设备极限吞吐量
- [x] 多设备并发（10, 50, 100）
- [x] 消息峰值负载（100,000 条）
- [x] Actor vs 同步对比
- [x] 多种数据类型
- [x] 内存和延迟监控
- [ ] 长时间稳定性测试（待实现）
- [ ] 真实频率模拟（待实现）
- [ ] 持久化存储场景（待实现）

---

**文档版本**：v1.0  
**最后更新**：2025-10-25  
**测试配置**：sendIntervalMs=0（极限压力测试）  
**峰值性能**：714,286 msg/s

